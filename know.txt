RailAnnounce is a production-style Django platform designed to let station operators craft announcements once and push them everywhere—spoken audio, live display boards, and staff notifications. Operators sign in, unlock the four-digit admin passcode, and fill out a rich announcement form (title, description, handler, priority, location, time, contact details). Submitting the form hands the record to the asynchronous pipeline where each step is automated.

The project relies on a Django 5 backend with session-based access control, Bootstrap 5 for responsive layout, GSAP 3 animations for hero/workflow motion, and Django Channels for WebSocket updates. Celery runs in tandem with a Redis broker so heavyweight work happens out of band: language detection (custom LanguageDetector service), multi-lingual translation via Gemini API with LibreTranslate as an offline fallback, text-to-speech through a Coqui/pyttsx3 wrapper, and Gmail SMTP notifications. Media files (audio) are stored under Django’s media root; display boards and announcement lists are animated with GSAP and styled with glassmorphism to keep the UI clean and contemporary.

Once an announcement is submitted, Celery tasks detect the source language, fan out translations to Hindi, Tamil, Telugu, Bengali, Kannada (plus English when needed), and generate TTS files. A second Celery call notifies connected clients in real time—display boards slide the new cards in without any reload. Admins can mark an announcement “fixed,” which flips the card green on every board and schedules a delay timer; within a minute the Celery task deletes it automatically. There is also tooling for test emails and setup scripts to quickly seed EMAIL_HOST_USER and EMAIL_HOST_PASSWORD.

Current limitations stem from the infrastructure assumptions. Celery requires a running Redis instance; without it, background work and email notifications stall. Coqui TTS models are large and may fail if the environment lacks GPU support or disk space, forcing a fall back to pyttsx3’s system voice which is less natural. The project expects a long-lived worker environment (not a serverless host like Vercel), and there is no user audit trail or analytics layer yet. Translations depend on the availability of Gemini or LibreTranslate, so outages there degrade accuracy.

Future enhancements can deepen reliability and insight. A queue dashboard (Flower or custom UI) would help operators monitor task health. Real-time analytics on announcement throughput, languages used, and resolution speed would surface operational trends. Offline-first improvements—packaging LibreTranslate and TTS models as services that boot with the app—would make the system resilient in low-connectivity stations. Finally, native mobile controls or kiosk touch panels would allow staff to trigger and mark announcements from the floor without needing the desktop UI.

